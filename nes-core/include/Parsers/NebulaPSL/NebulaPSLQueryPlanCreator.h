/*
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        https://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

#ifndef NES_PARSERS_NEBULAPSL_NEBULAPSLQUERYPLANCREATOR_H
#define NES_PARSERS_NEBULAPSL_NEBULAPSLQUERYPLANCREATOR_H

#include "NebulaPSLOperatorNode.h"
#include "NebulaPSLPattern.h"
#include <Common/DataTypes/DataTypeFactory.hpp>
#include <Nodes/Expressions/ConstantValueExpressionNode.hpp>
#include <Nodes/Expressions/LogicalExpressions/EqualsExpressionNode.hpp>
#include <Nodes/Expressions/LogicalExpressions/LessExpressionNode.hpp>
#include <Operators/LogicalOperators/Sinks/FileSinkDescriptor.hpp>
#include <Operators/LogicalOperators/Sinks/KafkaSinkDescriptor.hpp>
#include <Operators/LogicalOperators/Sinks/MQTTSinkDescriptor.hpp>
#include <Operators/LogicalOperators/Sinks/NetworkSinkDescriptor.hpp>
#include <Operators/LogicalOperators/Sinks/NullOutputSinkDescriptor.hpp>
#include <Operators/LogicalOperators/Sinks/OPCSinkDescriptor.hpp>
#include <Operators/LogicalOperators/Sinks/PrintSinkDescriptor.hpp>
#include <Operators/LogicalOperators/Sinks/ZmqSinkDescriptor.hpp>
#include <Parsers/NebulaPSL/gen/NesCEPBaseListener.h>
#include <Plans/Query/QueryPlan.hpp>
#include <string>

namespace NES {
/**
 * @brief This class creates the query plan from ANTLR AST
 * It inherits from the auto-generated ANTLR base listener to walk the AST created from the pattern string.
 * This enables the parsing of declarative patterns into NES queries.
 */

class NesCEPQueryPlanCreator : public NesCEPBaseListener {

  private:
    int sourceCounter = 0;
    int currentOperatorPointer = -1;
    int lastSeenSourcePtr = -1;
    NebulaPSLPattern pattern;
    int nodeId = 0;
    int currentElementPointer = -1;
    NES::Query query = NES::Query(NULL);

    bool inWhere = false;
    bool leftFilter = true;
    std::string currentLeftExp;
    std::string currentRightExp;

  public:
    int GetLastSeenSourcePtr() const;
    void SetLastSeenSourcePtr(int last_seen_source_ptr);
    int GetSourceCounter() const;
    void SetSourceCounter(int source_counter);
    int getNodeId() const;
    void setNodeId(int node_id);
    int GetCurrentElementPointer() const;
    void setCurrentElementPointer(int current_element_pointer);
    int GetCurrentParentPointer() const;
    void SetCurrentParentPointer(int current_parent_pointer);
    const NES::Query& getQuery() const;
    void SetQuery(const NES::Query& query);
    bool IsInWhere() const;
    void SetInWhere(bool in_where);
    bool IsLeftFilter() const;
    void SetLeftFilter(bool left_filter);
    const std::string& GetCurrentLeftExp() const;
    void SetCurrentLeftExp(const std::string& current_left_exp);
    const std::string& GetCurrentRightExp() const;
    void SetCurrentRightExp(const std::string& current_right_exp);

    /** the following methods read out the AST tree and collect all mined patterns in the global pattern list
     * An example of the AST looks as follows:
     * (query (cepPattern PATTERN test := (compositeEventExpressions (
        (listEvents (eventElem (event A)) (operatorRule AND) (eventElem (event B))) ))
        FROM (inputStreams (inputStream default_logical AS A) , (inputStream default_logical_b AS B))
        WHERE (whereExp (expression (predicate (predicate (expressionAtom (eventAttribute A . (attribute currentSpeed)))) (comparisonOperator <) (predicate (expressionAtom (eventAttribute A . (attribute allowedSpeed)))))))
        WITHIN (timeConstraints [ (interval 3 (intervalType MINUTE)) ])
        INTO (sinkList (sink (sinkType Print) :: testSink))) <EOF>
     * each keyword in the AST has its two functions, enter (when X is visited) and exist (called after all children of X have been visited), contained in the parent class NesCEPBaseListener,
     * auto-generated by the ANTLR dependency (gen-folders)
     */

    //ListEvents
    /** @brief mines pattern from the PATTERN clause
      * @param context
      */
    void enterListEvents(NesCEPParser::ListEventsContext* context) override;

    // EventElement
    /** @brief marks current (event) element as a child of the currentOperatorPointer subPattern and
      * move one step up in the AST hierarchy
      * @param context*/

    void enterEventElem(NesCEPParser::EventElemContext* context) override;

    // Event
    /**
      * @brief marks the position of the event inside of the currentElementPointer subPattern
      * @param context

    void enterEvent(NesCEPParser::EventContext* context) override;*/

    // Operators

    /**
      * @brief leaves the current operator element and changes direction to right to mine right branch for binary operators
      * @param context
      */
    void exitOperatorRule(NesCEPParser::OperatorRuleContext* context) override;

    // FROM clause
    /** @brief substitutes the input stream alias by its real name in every subPattern
      * @param context
      */
    void exitInputStream(NesCEPParser::InputStreamContext* context) override;

    // WHERE clause
    /** @brief marks that the tree walker starts parsing a WHERE clause
      * @param context
      */
    void enterWhereExp(NesCEPParser::WhereExpContext* context) override;

    /** @brief marks that the tree walker finished parsing the WHERE clause
      * @param context
      */
    void exitWhereExp(NesCEPParser::WhereExpContext* context) override;

    //INTO clause
    /**
      * @brief add a sink operator to the sink list
      * @param context
      */
    void enterSink(NesCEPParser::SinkContext* context) override;

    /** @brief append the list of sinks to the query plan
      * @param context
      */
    void exitSinkList(NesCEPParser::SinkListContext* context) override;

    // WITHIN clause
    /** @brief
      * @param context
      */
    void exitInterval(NesCEPParser::IntervalContext* cxt) override;

    /**
      * @brief collects all projection attributes
      * @param context
      */
    void enterOutAttribute(NesCEPParser::OutAttributeContext* context) override;

    /**
      * @brief add the appropriate iteration operator to the OperatorList
      * @param context
      */
    void enterQuantifiers(NesCEPParser::QuantifiersContext* context) override;

    /**
         * @brief extracts WHERE Expressions
         * @param context
         */
    void exitBinaryComparasionPredicate(NesCEPParser::BinaryComparasionPredicateContext* context) override;

    /**
         * @brief extracts Attributes in the WHERE
         * @param context
         */
    void enterAttribute(NesCEPParser::AttributeContext* context) override;

    /**
     * @brief this method creates the query from the NesPattern
     */
    NES::Query createQueryFromPatternList();

    /**
     * @brief this methods add all filter to the query
     */
    void addFilters();

    /**
     * @brief this methods parses the user-specified window information to TimeMeasures
     */
    std::pair<Windowing::TimeMeasure, Windowing::TimeMeasure> transformWindowToTimeMeasurements(std::string timeMeasure, int time );

    /**
     * @brief this methods add all projections to the query
     */
    void addProjections();
};

}//end of namespace NES

#endif //NES_PARSERS_NEBULAPSL_NEBULAPSLQUERYPLANCREATOR_H