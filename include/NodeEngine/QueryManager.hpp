#ifndef INCLUDE_QUERY_MANAGER__H_
#define INCLUDE_QUERY_MANAGER__H_

#include <NodeEngine/BufferManager.hpp>
#include <NodeEngine/ThreadPool.hpp>
#include <Plans/Query/QuerySubPlanId.hpp>
#include <QueryCompiler/QueryExecutionPlan.hpp>
#include <chrono>
#include <condition_variable>
#include <deque>
#include <map>
#include <mutex>
#include <shared_mutex>
#include <thread>
#include <unordered_set>

#include <NodeEngine/QueryStatistics.hpp>
#include <NodeEngine/Task.hpp>
#include <Sources/DataSource.hpp>
#include <Util/libcuckoo/cuckoohash_map.hh>
#include <Util/ThreadBarrier.hpp>
#include <Windows/WindowHandler.hpp>
#include <NodeEngine/Reconfigurable.hpp>
#include <memory>
#include <NodeEngine/ReconfigurationDescriptor.hpp>

namespace NES {

class TupleBuffer;

class CompiledExecutablePipeline;

class BufferManager;
typedef std::shared_ptr<BufferManager> BufferManagerPtr;

/**
 * @brief the query manager is the central class to process queries.
 * It is source-driven. Each incoming buffer will add a task to the queue.
 * The query manager maintains three structures:
 * 1.) a data_source map to map one data source to N queries
 * 2.) a window map to map one window to N queries TODO:maybe should be removed later
 * 3.) a data_sink to map one data sink to N queries
 * @Limitations:
 *    - statistics do not cover intermediate buffers
 */
class QueryManager : public std::enable_shared_from_this<QueryManager> {
  public:

    QueryManager() = delete;
    QueryManager(const QueryManager&) = delete;
    QueryManager& operator=(const QueryManager&) = delete;

    /**
     * @brief
     * @param bufferManager
     */
    explicit QueryManager(BufferManagerPtr bufferManager, uint64_t nodeEngineId);

    ~QueryManager();

    /**
     * @brief register a query by extracting sources, windows and sink and add them to
     * respective map
     * @param QueryExecutionPlan to be deployed
     */
    bool registerQuery(QueryExecutionPlanPtr qep);

    /**
     * @brief deregister a query by extracting sources, windows and sink and remove them
     * from respective map
     * @param QueryExecutionPlan to be deployed
     * @return bool indicating if register was successful
     */
    bool deregisterQuery(QueryExecutionPlanPtr qep);

    /**
     * @brief get task from task queue
     * @param bool indicating if the thread pool is still running
     * @return Pointer to task to execute
     * if thread pool was shut down while waiting, pointer points to empty task
     */
    Task getWork(std::atomic<bool>& threadPool_running);

    /**
     * @brief add work to the query manager, this methods is source-driven and is called
     * for each incoming buffer
     * @param Pointer to the tuple buffer containing the data
     * @param Pointer to the source at which the data arrived
     */
    void addWork(const std::string& sourceId, TupleBuffer& buf);

    /**
     * @brief add work to the query manager, this methods is source-driven and is called
     * for each buffer generated by the window trigger
     * @param Pointer to the tuple buffer containing the data
     * @param Pointer to the pipeline stage that will be executed next
     */
    void addWorkForNextPipeline(TupleBuffer& buffer, PipelineStagePtr nextPipeline);

    /**
     * @brief finalize task execution by:
     * 1.) update statistics (number of processed tuples and tasks)
     * 2.) release input buffer (give back to the buffer manager)
     * @param reference to processed task
     * @oaram reference to worker context
     */
    void completedWork(Task& task, WorkerContext& workerContext);

    /**
     * @brief get general statistics of QueryManager and Buffer Manager
     */
    std::string getQueryManagerStatistics();

    /**
     * @brief method to start a query
     * @param qep of the query to start
     * @return bool indicating success
     */
    bool startQuery(QueryExecutionPlanPtr qep);

    /**
     * @brief method to start a query
     * @param qep of the query to start
     * @return bool indicating success
     */
    bool stopQuery(QueryExecutionPlanPtr qep);

    /**
     * @brief notify all waiting threads in getWork() to wake up and try again
     */
    void unblockThreads() { cv.notify_all(); }

    /**
     * @brief reset query manager to intial state
     */
    void destroy();

    /**
     * @brief method to return the query statistics
     * @param qep of the particular query
     * @return
     */
    QueryStatisticsPtr getQueryStatistics(QuerySubPlanId qepId);

    size_t getNodeId() const;

    /**
     * @brief this methods adds a reconfiguration task on the worker queue
     * @return true if the reconfiguration task was added correctly on the worker queue
     * N.B.: this does not not mean that the reconfiguration took place but it means that it
     * was scheduled to be executed!
     * @param queryExecutionPlanId: the local QEP to reconfigure
     * @param reconfigurationDescriptor: what to do
     */
    bool addReconfigurationTask(QuerySubPlanId queryExecutionPlanId, ReconfigurationDescriptor reconfigurationDescriptor);

  private:
    friend class ThreadPool;
    friend class NodeEngine;
    /**
    * @brief method to start the thread pool
    * @param nodeEngineId the id of the owning node engine
    * @return bool indicating success
    */
    bool startThreadPool();

    void cleanup();
    void cleanupUnsafe();

    std::deque<Task> taskQueue;
    ThreadPoolPtr threadPool;

    std::map<std::string, std::unordered_set<QueryExecutionPlanPtr>> sourceIdToQueryMap;

    std::unordered_set<QueryExecutionPlanPtr> runningQEPs;

    //TODO:check if it would be better to put it in the thread context
    mutable std::mutex statisticsMutex;
    cuckoohash_map<QuerySubPlanId, QueryStatisticsPtr> queryToStatisticsMap;

    std::shared_mutex queryMutex;
    std::mutex workMutex;

    std::condition_variable cv;

    BufferManagerPtr bufferManager;
    std::shared_ptr<CompiledExecutablePipeline> reconfigurationExecutable;

    size_t nodeEngineId;
};

typedef std::shared_ptr<QueryManager> QueryManagerPtr;

}// namespace NES

#endif /* INCLUDE_query manager_H_ */
