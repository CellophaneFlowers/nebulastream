#ifndef INCLUDE_QUERY_MANAGER__H_
#define INCLUDE_QUERY_MANAGER__H_

#include <chrono>
#include <condition_variable>
#include <deque>
#include <map>
#include <mutex>
#include <thread>
#include <unordered_set>

#include <NodeEngine/BufferManager.hpp>
#include <NodeEngine/ThreadPool.hpp>
#include <QueryCompiler/QueryExecutionPlan.hpp>

#include <NodeEngine/Task.hpp>
#include <Sources/DataSource.hpp>
#include <Windows/WindowHandler.hpp>

#include <NodeEngine/QueryStatistics.hpp>
namespace NES {

class TupleBuffer;
/**
 * @brief the query manager is the central class to process queries.
 * It is source-driven. Each incoming buffer will add a task to the queue.
 * The query manager maintains three structures:
 * 1.) a data_source map to map one data source to N queries
 * 2.) a window map to map one window to N queries TODO:maybe should be removed later
 * 3.) a data_sink to map one data sink to N queries
 * @Limitations:
 *    - statistics do not cover intermediate buffers
 */
class QueryManager : public std::enable_shared_from_this<QueryManager> {
  public:
    /**
     * @brief Default constrcutor
     */
    QueryManager();

    /**
     * @brief register a query by extracting sources, windows and sink and add them to
     * respective map
     * @param QueryExecutionPlan to be deployed
     */
    bool registerQuery(QueryExecutionPlanPtr qep);

    /**
     * @brief deregister a query by extracting sources, windows and sink and remove them
     * from respective map
     * @param QueryExecutionPlan to be deployed
     * @return bool indicating if register was successful
     */
    bool deregisterQuery(QueryExecutionPlanPtr qep);

    /**
     * @brief get task from task queue
     * @param bool indicating if the thread pool is still running
     * @return Pointer to task to execute
     * if thread pool was shut down while waiting, pointer points to empty task
     * TODO: how is an empty task defined?
     */
    TaskPtr getWork(std::atomic<bool>& threadPool_running);

    /**
     * @brief add work to the query manager, this methods is source-driven and is called
     * for each incoming buffer
     * @param Pointer to the tuple buffer containing the data
     * @param Pointer to the source at which the data arrived
     */
    void addWork(const std::string& sourceId, TupleBuffer& buf);

    /**
     * @brief add work to the query manager, this methods is source-driven and is called
     * for each buffer generated by the window trigger
     * @param Pointer to the tuple buffer containing the data
     * @param Pointer to the window which generated the tuplebuffer
     */
    void addWorkForNextPipeline(TupleBuffer& buffer, QueryExecutionPlanPtr queryExecutionPlan, uint32_t pipelineId);

    /**
     * @brief finalize task execution by:
     * 1.) update statistics (number of processed tuples and tasks)
     * 2.) release input buffer (give back to the buffer manager)
     * @param Pointer processed task
     */
    void completedWork(TaskPtr task);

    /**
     * @brief get general statistics of QueryManager and Buffer Manager
     */
    std::string getQueryManagerStatistics();

    /**
     * @brief method to start a query
     * @param qep of the query to start
     * @return bool indicating success
     */
    bool startQuery(QueryExecutionPlanPtr qep);

    /**
     * @brief method to start a query
     * @param qep of the query to start
     * @return bool indicating success
     */
    bool stopQuery(QueryExecutionPlanPtr qep);

    /**
     * @brief notify all waiting threads in getWork() to wake up and try again
     */
    void unblockThreads() { cv.notify_all(); }

    /**
     * @brief reset query manager to intial state
     */
    void resetQueryManager();

    ~QueryManager();

    /**
     * @brief method to return the query statistics
     * @param qep of the particular query
     * @return
     */
    QueryStatisticsPtr getQueryStatistics(QueryExecutionPlanPtr qep);

  private:
    friend class ThreadPool;
    friend class NodeEngine;
    /**
    * @brief method to start the thread pool
    * @return bool indicating success
    */
    bool startThreadPool();

    /**
     * @brief method to stop thread pool
     * @return bool indicating success
     */
    bool stopThreadPool();

    QueryManager(const QueryManager&);
    QueryManager& operator=(const QueryManager&);

    void cleanup();
    void cleanupUnsafe();

    std::deque<TaskPtr> taskQueue;
    ThreadPoolPtr threadPool;

    std::map<std::string, std::unordered_set<QueryExecutionPlanPtr>> sourceIdToQueryMap;
    std::map<QueryExecutionPlanPtr, QueryStatisticsPtr> queryToStatisticsMap;

    std::mutex bufferMutex;
    std::mutex queryMutex;
    std::mutex workMutex;

    std::condition_variable cv;
};

typedef std::shared_ptr<QueryManager> QueryManagerPtr;

}// namespace NES

#endif /* INCLUDE_query manager_H_ */
